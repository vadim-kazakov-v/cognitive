<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cognitive Bias Visualizer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body class="container py-4">
  <h1 class="mb-4 text-center">Cognitive Bias Explorer</h1>
  <form id="upload-form" class="mb-3 d-flex gap-2">
    <input type="file" id="file-input" accept=".csv" class="form-control" />
    <button class="btn btn-primary" type="submit">Upload CSV</button>
  </form>
  <div class="mb-3">
    <label for="viz-select" class="form-label">Visualization</label>
    <select id="viz-select" class="form-select">
      <option value="circle">Circle Packing</option>
      <option value="bar">Bar Chart</option>
      <option value="webgl">WebGL 3D</option>
      </select>
    </div>
    <div id="chart"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>
    <script>
      const chartEl = d3.select('#chart');
      let currentData = [];
      let animationId;

    function drawCirclePacking(data) {
      const counts = Array.from(d3.rollup(data, v => v.length, d => d.category), ([category, count]) => ({category, count}));
      const width = 600, height = 400;
      const svg = chartEl.append('svg').attr('width', width).attr('height', height);
      const pack = d3.pack().size([width, height]).padding(10);
      const root = d3.hierarchy({children: counts}).sum(d => d.count);
      const nodes = pack(root).leaves();
      const color = d3.scaleOrdinal(d3.schemeSet2);
      const node = svg.selectAll('g').data(nodes).enter().append('g').attr('transform', d => `translate(${d.x},${d.y})`);
      node.append('circle').attr('r', d => d.r).attr('fill', d => color(d.data.category));
      node.append('text').classed('label', true).attr('text-anchor', 'middle').attr('dy', '.3em').text(d => d.data.category);
    }

      function drawBarChart(data) {
        const counts = Array.from(d3.rollup(data, v => v.length, d => d.category), ([category, count]) => ({category, count}));
        const width = 600, height = 400, margin = {top: 20, right: 20, bottom: 40, left: 40};
        const svg = chartEl.append('svg').attr('width', width).attr('height', height);
        const x = d3.scaleBand().domain(counts.map(d => d.category)).range([margin.left, width - margin.right]).padding(0.1);
        const y = d3.scaleLinear().domain([0, d3.max(counts, d => d.count)]).nice().range([height - margin.bottom, margin.top]);
        svg.append('g').selectAll('rect').data(counts).enter().append('rect')
          .attr('x', d => x(d.category)).attr('y', d => y(d.count))
          .attr('width', x.bandwidth()).attr('height', d => y(0) - y(d.count))
          .attr('fill', '#69b3a2');
        svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(x));
        svg.append('g').attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y));
      }

      function drawWebGL(data) {
        const counts = Array.from(d3.rollup(data, v => v.length, d => d.category), ([category, count]) => ({category, count}));
        const width = 600, height = 400;
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(width, height);
        chartEl.node().appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);
        camera.position.z = 5;

        counts.forEach((d, i) => {
          const geometry = new THREE.SphereGeometry(0.3 + d.count * 0.1);
          const material = new THREE.MeshBasicMaterial({color: new THREE.Color(`hsl(${i / counts.length * 360},70%,50%)`)});
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.x = (i - counts.length / 2) * 1.2;
          scene.add(mesh);
        });

        function animate() {
          scene.rotation.y += 0.01;
          renderer.render(scene, camera);
          animationId = requestAnimationFrame(animate);
        }
        animate();
      }

      function render(data) {
        chartEl.selectAll('*').remove();
        if (animationId) cancelAnimationFrame(animationId);
        const viz = document.getElementById('viz-select').value;
        if (viz === 'bar') {
          drawBarChart(data);
        } else if (viz === 'webgl') {
          drawWebGL(data);
        } else {
          drawCirclePacking(data);
        }
      }

    document.getElementById('viz-select').addEventListener('change', () => render(currentData));

    document.getElementById('upload-form').addEventListener('submit', e => {
      e.preventDefault();
      const fileInput = document.getElementById('file-input');
      if (!fileInput.files.length) return;
      const formData = new FormData();
      formData.append('file', fileInput.files[0]);
      fetch('/upload', { method: 'POST', body: formData })
        .then(res => res.json())
        .then(data => { currentData = data; render(currentData); });
    });

    function loadDefault() {
      fetch('/api/biases').then(res => res.json()).then(data => { currentData = data; render(currentData); });
    }

    loadDefault();
  </script>
</body>
</html>
